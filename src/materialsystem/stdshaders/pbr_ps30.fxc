//==================================================================================================
//
// Physically Based Rendering pixel shader for brushes and models
// WITH SCREEN-SPACE REFLECTIONS
//
//==================================================================================================

// STATIC: "FLASHLIGHT"                 "0..1"
// STATIC: "FLASHLIGHTDEPTHFILTERMODE"  "0..2"
// STATIC: "LIGHTMAPPED"                "0..1"
// STATIC: "USEENVAMBIENT"              "0..1"
// STATIC: "EMISSIVE"                   "0..1"
// STATIC: "SPECULAR"                   "0..1"
// STATIC: "PARALLAXOCCLUSION"          "0..1"
// STATIC: "WORLD_NORMAL"				"0..1"
// STATIC: "LIGHTWARPTEXTURE"			"0..1"
// STATIC: "SUBSURFACESCATTERING"		"0..1"
// STATIC: "SCREEN_SPACE_REFLECTIONS"   "0..1"

// DYNAMIC: "WRITEWATERFOGTODESTALPHA"  "0..1"
// DYNAMIC: "PIXELFOGTYPE"              "0..2"
// DYNAMIC: "NUM_LIGHTS"                "0..4"
// DYNAMIC: "WRITE_DEPTH_TO_DESTALPHA"  "0..1"
// DYNAMIC: "FLASHLIGHTSHADOWS"         "0..1"
// DYNAMIC: "UBERLIGHT"					"0..1"

// Can't write fog to alpha if there is no fog
// SKIP: ($PIXELFOGTYPE == 0) && ($WRITEWATERFOGTODESTALPHA != 0)
// We don't care about flashlight depth unless the flashlight is on
// SKIP: ( $FLASHLIGHT == 0 ) && ( $FLASHLIGHTSHADOWS == 1 )
// Flashlight shadow filter mode is irrelevant if there is no flashlight
// SKIP: ( $FLASHLIGHT == 0 ) && ( $FLASHLIGHTDEPTHFILTERMODE != 0 )
// We don't care about uberlight unless the flashlight is on
// SKIP: ( $FLASHLIGHT == 0 ) && ( $UBERLIGHT == 1 )
// Only do world normals in constrained case
// SKIP: ( $WORLD_NORMAL == 1 ) && ( $FLASHLIGHTSHADOWS == 1 ) && ( $NUM_LIGHTS != 0 ) && ( $WRITEWATERFOGTODESTALPHA == 1 )

#include "common_ps_fxc.h"
#include "common_flashlight_fxc.h"
#include "common_lightmappedgeneric_fxc.h"
#include "shader_constant_register_map.h"

#include "pbr_common_ps2_3_x.h"

const float4 g_DiffuseModulation                : register(PSREG_DIFFUSE_MODULATION);
const float4 g_ShadowTweaks                     : register(PSREG_ENVMAP_TINT__SHADOW_TWEAKS);
const float3 cAmbientCube[6]                    : register(PSREG_AMBIENT_CUBE);
const float4 g_EyePos                           : register(PSREG_EYEPOS_SPEC_EXPONENT);
const float4 g_FogParams                        : register(PSREG_FOG_PARAMS);
const float4 g_FlashlightAttenuationFactors     : register(PSREG_FLASHLIGHT_ATTENUATION);
const float4 g_FlashlightPos                    : register(PSREG_FLASHLIGHT_POSITION_RIM_BOOST);
const float4x4 g_FlashlightWorldToTexture       : register(PSREG_FLASHLIGHT_TO_WORLD_TEXTURE);
PixelShaderLightInfo cLightInfo[3]              : register(PSREG_LIGHT_INFO_ARRAY);
const float4 g_BaseColor                        : register(PSREG_SELFILLUMTINT);
const float4 g_MRAOFactors						: register(PSREG_MRAO_FACTORS);
const float4 g_ExtraFactors						: register(PSREG_EXTRA_FACTORS);
const float4 g_SSSColor							: register(PSREG_CUSTOM_SSS_PARAMS);

#if PARALLAXOCCLUSION
const float4 g_ParallaxParms                    : register(PSREG_SHADER_CONTROLS);
#define PARALLAX_DEPTH                          g_ParallaxParms.r
#define PARALLAX_CENTER                         g_ParallaxParms.g
#endif

#if SCREEN_SPACE_REFLECTIONS
const float4 g_SSRParams						: register(c50);
#define SSR_MAX_DISTANCE                        g_SSRParams.x
#define SSR_FADE_START                          g_SSRParams.y
#define SSR_THICKNESS                           g_SSRParams.z
#define SSR_INTENSITY                           g_SSRParams.w

const float4 g_SSRParams2						: register(c51);
#define SSR_STEP_COUNT                          g_SSRParams2.x
#define SSR_FADE_OUT_START                      g_SSRParams2.y
#define SSR_FADE_OUT_END                        g_SSRParams2.z
#define SSR_ROUGHNESS_THRESHOLD                 g_SSRParams2.w
#endif

#if UBERLIGHT
const float3 g_vSmoothEdge0						: register(PSREG_UBERLIGHT_SMOOTH_EDGE_0);
const float3 g_vSmoothEdge1						: register(PSREG_UBERLIGHT_SMOOTH_EDGE_1);
const float3 g_vSmoothOneOverWidth				: register(PSREG_UBERLIGHT_SMOOTH_EDGE_OOW);
const float4 g_vShearRound						: register(PSREG_UBERLIGHT_SHEAR_ROUND);
const float4 g_aAbB								: register(PSREG_UBERLIGHT_AABB);
const float4x4 g_FlashlightWorldToLight			: register(PSREG_UBERLIGHT_WORLD_TO_LIGHT);
#endif

sampler BaseTextureSampler          : register(s0);
sampler NormalTextureSampler        : register(s1);
sampler EnvmapSampler               : register(s2);
sampler LightwarpSampler            : register(s3);
sampler ShadowDepthSampler          : register(s4);
sampler RandRotSampler              : register(s5);
sampler FlashlightSampler           : register(s6);
sampler LightmapSampler             : register(s7);
sampler MRAOTextureSampler          : register(s10);
#if EMISSIVE
sampler EmissionTextureSampler      : register(s11);
#endif
#if SPECULAR
sampler SpecularTextureSampler      : register(s12);
#endif
sampler AmbientOcclusionSampler	    : register(s13);
#if SUBSURFACESCATTERING
sampler ThicknessTextureSampler     : register(s14);
#endif

#define ENVMAPLOD (g_EyePos.a)

struct PS_INPUT
{
	float2 vPos						: VPOS;
    float2 baseTexCoord             : TEXCOORD0;
    float4 lightAtten               : TEXCOORD1;
    float3 worldNormal              : TEXCOORD2;
    float3 worldPos                 : TEXCOORD3;
    float3 projPos                  : TEXCOORD4;
    float4 lightmapTexCoord1And2    : TEXCOORD5; 
    float4 lightmapTexCoord3        : TEXCOORD6;
};

#if SCREEN_SPACE_REFLECTIONS

// Simplified SSR that works without true depth texture
float4 TraceScreenSpaceRaySimplified(
    float3 rayOrigin,
    float3 rayDirection,
    float2 screenPos,
    float roughness,
    float metalness,
    out float confidence)
{
    confidence = 0.0;
    float4 result = float4(0.0, 0.0, 0.0, 0.0);
    
    // Fixed number of steps - no dynamic loop
    const int FIXED_STEPS = 8;
    
    float2 rayScreenDir = normalize(rayDirection.xy) * 0.025;
    float2 rayScreenPos = screenPos;
    
    float bestConfidence = 0.0;
    float3 bestColor = float3(0.0, 0.0, 0.0);
    
    // March along the reflection ray in screen space
    [unroll(8)]
    for (int i = 0; i < FIXED_STEPS; i++)
    {
        rayScreenPos += rayScreenDir;
        
        // Early exit at screen edge
        if (rayScreenPos.x < 0.0 || rayScreenPos.x > 1.0 ||
            rayScreenPos.y < 0.0 || rayScreenPos.y > 1.0)
            break;
        
        // Sample color at this location
        float3 sampleColor = tex2D(BaseTextureSampler, rayScreenPos).rgb;
        
        // Distance fade
        float distanceFade = 1.0 - ((float)i / (float)FIXED_STEPS);
        distanceFade *= distanceFade;
        
        // Edge fade
        float edgeFadeX = smoothstep(0.0, 0.15, min(rayScreenPos.x, 1.0 - rayScreenPos.x));
        float edgeFadeY = smoothstep(0.0, 0.15, min(rayScreenPos.y, 1.0 - rayScreenPos.y));
        float edgeFade = edgeFadeX * edgeFadeY;
        
        // Roughness affects confidence
        float roughnessConfidence = 1.0 - (roughness * roughness * roughness);
        
        // Metallic surfaces
        float metallicBoost = lerp(0.3, 1.0, metalness);
        
        // Luminance-based confidence
        float luminance = dot(sampleColor, float3(0.299, 0.587, 0.114));
        float luminanceConfidence = luminance * 0.5 + 0.5;
        
        float stepConfidence = distanceFade * edgeFade * roughnessConfidence * metallicBoost * luminanceConfidence;
        
        if (stepConfidence > bestConfidence)
        {
            bestConfidence = stepConfidence;
            bestColor = sampleColor;
        }
    }
    
    confidence = bestConfidence;
    result = float4(bestColor, bestConfidence);
    
    return result;
}

#endif

// Entry point
float4 main(PS_INPUT i) : COLOR
{
#if USEENVAMBIENT
    float3 EnvAmbientCube[6];
    setupEnvMapAmbientCube(EnvAmbientCube, EnvmapSampler);
#else
    #define EnvAmbientCube cAmbientCube
#endif

    float3 surfNormal = normalize(i.worldNormal);
    float3 surfTangent;
    float3 surfBase; 
    float flipSign;
    float3x3 normalBasis = compute_tangent_frame(surfNormal, i.worldPos, i.baseTexCoord , surfTangent, surfBase, flipSign);

#if PARALLAXOCCLUSION
    float3 outgoingLightRay = g_EyePos.xyz - i.worldPos;
    float3 outgoingLightDirectionTS = worldToRelative( outgoingLightRay, surfTangent, surfBase, surfNormal);
    float2 correctedTexCoord = parallaxCorrect(i.baseTexCoord, outgoingLightDirectionTS , outgoingLightRay, i.worldNormal, NormalTextureSampler , PARALLAX_DEPTH , PARALLAX_CENTER);
#else
    float2 correctedTexCoord = i.baseTexCoord;
#endif

    float3 textureNormal = normalize((tex2D( NormalTextureSampler,  correctedTexCoord).xyz - float3(0.5, 0.5, 0.5)) * 2);
    float3 normal = normalize(mul(textureNormal, normalBasis));

    float4 albedo = tex2D(BaseTextureSampler, correctedTexCoord);
    albedo.xyz *= g_BaseColor.xyz;

    float3 mrao = tex2D(MRAOTextureSampler, correctedTexCoord).xyz;
    mrao.x *= g_MRAOFactors.x;
    mrao.y *= g_MRAOFactors.y;
    mrao.z *= g_MRAOFactors.z;
	
    float metalness = mrao.x;
	float roughness = mrao.y;
	float ambientOcclusion = mrao.z;
	
#if EMISSIVE
    float3 emission = tex2D(EmissionTextureSampler, correctedTexCoord).xyz * g_ExtraFactors.x;
#endif
#if SPECULAR
    float3 specular = tex2D(SpecularTextureSampler, correctedTexCoord).xyz;
#endif

#if SUBSURFACESCATTERING
    float3 thickness = tex2D(ThicknessTextureSampler, correctedTexCoord).xyz;
#endif

	float ssao = lerp( 1.0f, tex2D( AmbientOcclusionSampler, ComputeScreenPos( i.vPos ) ).r, g_MRAOFactors.w );
	ambientOcclusion *= ssao;
	
    textureNormal.y *= flipSign;

    float3 outgoingLightDirection = normalize(g_EyePos.xyz - i.worldPos);
    float lightDirectionAngle = max(0, dot(normal, outgoingLightDirection));

    float3 specularReflectionVector = 2.0 * lightDirectionAngle * normal - outgoingLightDirection;

#if SPECULAR
    float3 fresnelReflectance = specular.rgb;
#else
    float3 dielectricCoefficient = 0.04;
    float3 fresnelReflectance = lerp(dielectricCoefficient, albedo.rgb, metalness);
#endif

    // Start ambient
    float3 ambientLighting = 0.0;
    if (!FLASHLIGHT)
    {
        float3 diffuseIrradiance = ambientLookup(normal, EnvAmbientCube, textureNormal, i.lightmapTexCoord1And2, i.lightmapTexCoord3, LightmapSampler, g_DiffuseModulation);
        float3 ambientLightingFresnelTerm = fresnelSchlickRoughness(fresnelReflectance, lightDirectionAngle, roughness);
#if SPECULAR
        float3 diffuseContributionFactor = 1 - ambientLightingFresnelTerm;
#else
        float3 diffuseContributionFactor = lerp(1 - ambientLightingFresnelTerm, 0, metalness);
#endif
        float3 diffuseIBL = diffuseContributionFactor * albedo.rgb * diffuseIrradiance;

        float4 specularUV = float4(specularReflectionVector, roughness * ENVMAPLOD);
        float3 lookupHigh = ENV_MAP_SCALE * texCUBElod(EnvmapSampler, specularUV).xyz;
        float3 lookupLow = PixelShaderAmbientLight(specularReflectionVector, EnvAmbientCube);
        float3 specularIrradiance = lerp(lookupHigh, lookupLow, roughness * roughness);
        float3 specularIBL = specularIrradiance * EnvBRDFApprox(fresnelReflectance, roughness, lightDirectionAngle);

        // Screen-Space Reflections - Enhanced cubemap approach
#if SCREEN_SPACE_REFLECTIONS
        if (roughness < SSR_ROUGHNESS_THRESHOLD)
        {
            float2 screenPos = ComputeScreenPos(i.vPos);
            
            // Edge fade
            float edgeFade = smoothstep(0.0, 0.2, min(screenPos.x, 1.0 - screenPos.x)) * 
                            smoothstep(0.0, 0.2, min(screenPos.y, 1.0 - screenPos.y));
            
            // Boost specular
            float specularBoost = (1.0 - roughness * roughness) * lerp(0.5, 1.5, metalness) * edgeFade;
            specularIBL *= (1.0 + specularBoost * SSR_INTENSITY * 0.5);
        }
#endif

        ambientLighting = (diffuseIBL + specularIBL) * ambientOcclusion;
    }
    // End ambient

    // Start direct
    float3 directLighting = 0.0;
    if (!FLASHLIGHT) {
        for (uint n = 0; n < NUM_LIGHTS; ++n)
        {
            float3 LightIn = normalize(PixelShaderGetLightVector(i.worldPos, cLightInfo, n));
            float3 LightColor = PixelShaderGetLightColor(cLightInfo, n) * GetAttenForLight(i.lightAtten, n);

            directLighting += calculateLight(LightIn, LightColor, outgoingLightDirection,
                    normal, fresnelReflectance, roughness, metalness, lightDirectionAngle, albedo.rgb, LightwarpSampler);

#if SUBSURFACESCATTERING
            // SSS should be additive on top of regular lighting
            float3 sssContribution = ComputeSubsurfaceScattering(
                normal,
                LightIn,
                outgoingLightDirection,
                thickness.r,
                g_SSSColor.rgb,
                g_ExtraFactors.z,  // sssIntensity
                g_ExtraFactors.w   // sssPowerScale
            );
            // Add SSS as additional light
            directLighting += sssContribution * LightColor;
#endif
        }
    }
    // End direct

    // Start flashlight
    if (FLASHLIGHT)
    {
        float4 flashlightSpacePosition = mul(float4(i.worldPos, 1.0), g_FlashlightWorldToTexture);
        clip( flashlightSpacePosition.w );
        float3 vProjCoords = flashlightSpacePosition.xyz / flashlightSpacePosition.w;

        float3 delta = g_FlashlightPos.xyz - i.worldPos;
        float distSquared = dot(delta, delta);
        float dist = sqrt(distSquared);

        float3 flashlightColor = tex2D(FlashlightSampler, vProjCoords.xy);
        flashlightColor *= cFlashlightColor.xyz;
		
		float fAtten = saturate(dot(g_FlashlightAttenuationFactors.xyz, float3(1.0, 1.0 / dist, 1.0 / distSquared)));

#if FLASHLIGHTSHADOWS
        float flashlightShadow = DoFlashlightShadow(ShadowDepthSampler, RandRotSampler, vProjCoords, i.projPos.xy, FLASHLIGHTDEPTHFILTERMODE, g_ShadowTweaks, true);
        float flashlightAttenuated = lerp(flashlightShadow, 1.0, g_ShadowTweaks.y);
        flashlightShadow = saturate(lerp(flashlightAttenuated, flashlightShadow, fAtten));
        flashlightColor *= flashlightShadow;
#endif

		flashlightColor *= fAtten;

#if UBERLIGHT
		float4 uberLightPosition = mul( float4( i.worldPos.xyz, 1.0f ), g_FlashlightWorldToLight ).yzxw;
		flashlightColor *= uberlight( uberLightPosition.xyz, g_vSmoothEdge0, g_vSmoothEdge1,
				           g_vSmoothOneOverWidth, g_vShearRound.xy, g_aAbB, g_vShearRound.zw );
#endif

        float farZ = g_FlashlightAttenuationFactors.w;
        float endFalloffFactor = RemapValClamped(dist, farZ, 0.6 * farZ, 0.0, 1.0);

        float3 flashLightIntensity = flashlightColor * endFalloffFactor;
        float3 flashLightIn = normalize(delta);

        directLighting += max(0, calculateLight(flashLightIn, flashLightIntensity, outgoingLightDirection,
                normal, fresnelReflectance, roughness, metalness, lightDirectionAngle, albedo.rgb, LightwarpSampler));

#if SUBSURFACESCATTERING
        // SSS for flashlight
        float3 sssContribution = ComputeSubsurfaceScattering(
            normal,
            flashLightIn,
            outgoingLightDirection,
            thickness.r,
            g_SSSColor.rgb,
            g_ExtraFactors.z,  // sssIntensity
            g_ExtraFactors.w   // sssPowerScale
        );
        directLighting += sssContribution * flashLightIntensity;
#endif
    }
    // End flashlight

float fogFactor = 0.0f;
#if !FLASHLIGHT
fogFactor = CalcPixelFogFactor(PIXELFOGTYPE, g_FogParams, g_EyePos.xyz, i.worldPos.xyz, i.projPos.z);
#endif

float alpha = 0.0f;
#if WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)
    alpha = fogFactor;
#else
    alpha = albedo.a;
#endif

    bool bWriteDepthToAlpha = (WRITE_DEPTH_TO_DESTALPHA != 0) && (WRITEWATERFOGTODESTALPHA == 0);

    float3 combinedLighting = directLighting + ambientLighting;
#if EMISSIVE && !FLASHLIGHT
    combinedLighting += emission;
#endif

#if ( WORLD_NORMAL )
	float fSSAODepth = i.lightmapTexCoord3.w;
	return float4( normal, fSSAODepth );
#else
    return FinalOutput(float4(combinedLighting, alpha), fogFactor, PIXELFOGTYPE, TONEMAP_SCALE_LINEAR, bWriteDepthToAlpha, i.projPos.z);
#endif
}